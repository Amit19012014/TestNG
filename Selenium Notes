Day 21
-------

Selenium WebDriver
====================

1) WebDriver is one of the component in selenium.
2) webDriver is a java Interface
3) WebDriver is an API (Application Programming Interface)

WebDriver (I)---->  RemoteWebDriver (C)----> ChromeDriver , FirefoxDriver , EdgeDriver etc.....


Day 22
---------

Locators (ID,Name,LinkText,PartialLinkText,Class&Tag)
====================================================

We can identify various elements on the web using Locators
Locators are addresses that identify a web element uniquely within the page

Locators
=========
ID,
Name,
LinkText, - we need to write full text
PartialLinkText - write Partial text
Class&Tag - use to collect group of element

Customized Locators
====================
CSS Selector
-------------
Tag and ID
Tag and class
Tag and attribute
Tag class and attribute

Xpath
-------------
Absolute xpath
Relative xpath

driver.findelement(By.id("")).click()

findElement() - will return single Webelement
findElements() - will return multiple Webelements


Scenario 1 : Locator matching with single web element

findElement(loc) ---> single web element --- Web-element
findElements(loc) ----> single web element List<WebElement>

Scenario 2 : Locator matching with multiple web elements
findElement(loc) ---> single web element --- Web-element
findElements(loc) ----> multiple web element List<WebElement>

Scenario 3 : Locator is not matching with any web elements
findElement(loc) ---> NoSuchElementException
findElements(loc) ----> return 0. because List<WebElement> will not find any element so it is 0. Empty list will be created.


Day 23
---------
Locators - CSS Selector
=======================

CSS - Cascading Style Sheets

tag id                        tag#id
tag class                     tag.class_name
tag attribute                 tag[attribute = "value"]
tag class attribute           tag.class_name[attribute = "value"]



Day 24
==========
(XML Language)

Locators -  XPath | XPath Functions | XPath
============================================
Xpath is an address of the element
DOM - Document object model

type of
=============
1)absolute Xpath (Full Xpath)

    Ex: /html/body/div[6]/div[1]/div[2]/div[2]/form/button

2)relative Xpath (Partial Xpath)

    Ex: //*[@id="small-search-box-form"]/button

Which Xpath will be preferred?
Relative Xpath

Difference B/W Absolute & Relative Xpath
-----------------------------------------

Difference between Absolute & Relative Xpaths?
1) Absolute xpath starts with / ---> represents root node
   Relative xpath starts with //

2) Absolute xpath do not use attributes
   Relative xpath works with attribute

3) Absolute xpath traverse through each node till it finds element
   Relative xpath directly jump and find the element by using attribute

Relative Xpath (Partial Xpath)
--------------------------------

1)Automatically ( By Dev tools, selector hub)
2)Manually (OWN Xpath)

Syntax
---------
//tagname[@attribute='value']
//*[@attribute='value']


Example 1
---------
//img[@title='MacBook']
//*[@title='MacBook']

//*[@title=/"MacBook"/]



//Xpath with single Attribute
-----------------------------
driver.findElement(By.xpath("//input[@placeholder='Search']")).sendKeys("Amit");

//Xpath with multiple Attribute
-------------------------------
driver.findElement(By.xpath("//input[@name='search'][@placeholder='Search']")).sendKeys("Amit");

Xpath with 'and' & 'or' operators
------------------------------
//input[@name='search' and @placeholder='Search']
//input[@name='search' or @placeholder='Search']

Xpath with inner text ---text()
-------------------------------
Syntax
//tagname[text() ='innerText']

//a[text()='Desktop'];
//a[text()='MacBook'];

<a href="https://xyz.com"> Click me </a>

linktext  - yes
innertext - yes

<div>welcome</div>

linktext  - no
innertext - yes

Xpath with Contains()
=====================
it will check the keyword anywhere on the webpage
//input[contains(.,'Sea')] here (.) is  text() method
//input[contains(@placeholder,'Sea')]

Xpath with start-with()
=======================
it will check the keyword from the starting.
//input[starts-with(@placeholder,'Sea')]

Handling Dynamic attributes
============================

//*[@id='start' or @id='stop']
//*[contains(@id,'st')]
//*[starts-with(@id,'st')]


name = xyz001 xyz002  xyz003 xyz004
//*[contains(@name,'xyz')]
//*[starts-with(@name,'xyz')]

//*[contains(@name,'00')]

name = 1xyz 2xyz 3xyz 4xyz 5xyz

//*[contains(@name,'xyz')]

name = 101xyz 201xyz 301xyz 401xyz

//*[contains(@name,'xyz')]

Chained Xpath
==============
the combination of absolute and relative Xpath is called chained Xpath

Example :

//div[@class='col-sm-4']/div/h1/a[contains(text(),'Your Store')]




Day 25
==========
Locators - XPath Axes | SelectorsHub
=====================================

XPath Axes :
------------

child – Selects all direct children of the current node.

parent – Selects the parent of the current node.

ancestor – Selects all ancestors (parent, grandparent, etc.) of the current node.

ancestor-or-self – Selects the current node and all its ancestors.

descendant – Selects all descendants (children, grandchildren, etc.) of the current node.

descendant-or-self – Selects the current node and all its descendants.

following – Selects all nodes after the current node in the document.

following-sibling – Selects all siblings after the current node.

preceding – Selects all nodes before the current node in the document.

preceding-sibling – Selects all siblings before the current node.

self – Selects the current node itself.

attribute – Selects all attributes of the current node.

namespace – Selects all namespace nodes of the current node (rarely used).

XPath Axes - Definitions and Examples
=====================================

Sample HTML Structure:
----------------------
<html>
  <body>
    <div>
      <h1>Title</h1>
      <p>Paragraph 1</p>
      <p>Paragraph 2</p>
      <span>Note</span>
    </div>
  </body>
</html>

Axes List:
----------
1. self
    - Description: Selects the current node itself
    - Example: //h1/self::h1
    - Selects: The <h1> node

2. child
   - Description: Selects direct children of the current node
   - Example: //div/child::p
   - Selects: <p>Paragraph 1</p>, <p>Paragraph 2</p>

3. parent
   - Description: Selects the parent of the current node
   - Example: //span/parent::div
   - Selects: <div> that contains the <span>

4. descendant
   - Description: Selects all descendants (children, grandchildren, etc.)
   - Example: //div/descendant::p
   - Selects: All <p> elements inside <div>

5. ancestor
   - Description: Selects all ancestors (parent, grandparent, etc.)
   - Example: //p/ancestor::div
   - Selects: The <div> wrapping the <p>

6. following
   - Description: Selects all nodes after the current node in the document
   - Example: //h1/following::p
   - Selects: All <p> elements after <h1>

7. following-sibling
   - Description: Selects siblings after the current node
   - Example: //h1/following-sibling::p
   - Selects: <p>Paragraph 1</p>, <p>Paragraph 2</p>

8. preceding
   - Description: Selects all nodes before the current node in the document
   - Example: //span/preceding::h1
   - Selects: <h1> before <span>

9. preceding-sibling
    - Description: Selects siblings before the current node
    - Example: //p[2]/preceding-sibling::p
    - Selects: <p>Paragraph 1</p>



Day 26
==========

WebDriver Methods
==================



1) get methods :- we can access these methods through WebDriver instance.
==============
get(url) opens the url on the browser
getTitle() returns title of the page
getCurrentUrl() returns URL of the page
getPageSource() returns source code of the page
getWindowHandle() returns ID of the single Browser window
getWindowHandles() returns ID's of the multiple browser windows

2) conditional methods :- access these commands through WebElement
======================
returns boolean value(true/false)

isDisplayed() - We can check display status of internet
isEnable() - we can check enable/disable status of the element/operational element.
isSelected() - we can use to check the element is selected or not.


3) browser methods
==================

close() - close single browser window wherever driver is focused
quit() - close multiple browsers windows


4) navigational methods
=======================



Assignments - https://testautomationpractice.blogspot.com/


Day 27
======

Wait methods (commands)
=======================

Synchronization -

Thread.sleep() - it is java command

1)Implicit wait
2)Explicit wait / fluent wait


NoSuchElementException - Element is not present on the page. Synchronization Problem.
ElementNotFoundException - Locator is incorrect



Thread.sleep()
===============
Advantage

1) easy to use

Disadvantage

1) if the time is not sufficient then you will get exception
2) it will wait for maximum time out. this will reduce the performance script.
3) multiple times

1)Implicit wait
==================
driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));

Advantage
==========

1) single time/one statement
2) it will not wait till maximum time if the element is available
3) Applicable for all the elements
4) easy to use

Disadvantage:
===========

1) if the time is not sufficient then you will get exception


2) Explicit wait
===================

declaration
use


1) Conditional based, it will work more effectively.
2) finding element is inclusive( for some conditions)
3) it will wait for condition to be true, then consider the time
4) we need to write multiple statements for multiple elements


conditions
===============

alertlsPresent()
elementSelectionStateToBe() elementToBeClickable()
elementToBeSelected()
frameToBeAvaliableAndSwitchTolt()
presenceOfAllElementsLocatedBy()
presenceOfElementLocated()
textToBePresentinElement()
textToBePresentinElementLocated()
textToBePresentInElementValue()
titlels()
titleContains()
visibilityOf()
visibilityOfAllElements()
visibilityOfAllElementsLocatedBy()
visibilityOfElementLocated()

fluent wait
==============

  // Waiting 30 seconds for an element to be present on the page, checking
   // for its presence once every 5 seconds.
   Wait<WebDriver> wait = new FluentWait<WebDriver>(driver)
       .withTimeout(Duration.ofSeconds(time))
       .pollingEvery(Duration.ofSeconds(time))
       .ignoring(NoSuchElementException.class);

   WebElement foo = wait.until(new Function<WebDriver, WebElement>() {
     public WebElement apply(WebDriver driver) {
       return driver.findElement(By.id("foo"));
     }
   });